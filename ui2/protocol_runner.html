<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocol Runner - UI2</title>
    <link rel="stylesheet" href="css/theme.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="js/api.js"></script>
    <script src="js/utils.js"></script>
    <style>
        .runner-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 1rem;
            max-width: 1600px;
            margin: 0 auto;
            height: calc(100vh - 80px);
            overflow: hidden;
        }

        .protocol-source-toggle {
            display: flex;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 1rem;
        }

        .source-btn {
            flex: 1;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            padding: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .source-btn.active {
            background: var(--accent-cyan);
            color: #000;
        }

        .protocol-list-mini {
            max-height: 180px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            border-radius: 8px;
        }

        .proto-item {
            padding: 6px 10px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .proto-item:last-child {
            border-bottom: none;
        }

        .proto-item:hover {
            background: rgba(0, 212, 255, 0.05);
        }

        .proto-item.active {
            background: rgba(0, 212, 255, 0.1);
            border-left: 4px solid var(--accent-cyan);
        }

        .proto-item .name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            display: block;
        }

        .proto-item .id {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        /* Metric Cards - Compact */
        .metrics-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .metric-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--accent-green);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .metric-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .metric-value {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Overrides Accordion - Compact */
        .override-section {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.6rem 0.8rem;
            margin-bottom: 0.5rem;
        }

        .section-header {
            font-size: 0.8rem;
            font-weight: 700;
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            color: var(--accent-cyan);
            cursor: pointer;
            user-select: none;
        }

        .section-header:hover {
            opacity: 0.8;
        }

        .override-section.collapsed {
            padding-bottom: 0.4rem;
        }

        .override-section.collapsed #setupContent {
            display: none;
        }

        /* Compact form elements */
        .form-group {
            margin-bottom: 0.3rem;
        }

        .form-group label {
            font-size: 0.7rem;
            margin-bottom: 0.1rem;
        }

        .form-group input,
        .form-group select {
            padding: 0.25rem 0.4rem;
            font-size: 0.75rem;
            height: 28px;
        }

        .group-title {
            font-size: 0.75rem;
            margin: 0.4rem 0 0.2rem 0;
        }

        .divider {
            margin: 0.3rem 0;
        }

        .override-section.collapsed .section-header {
            margin-bottom: 0;
        }

        /* Execution Styles - Compact */
        .btn-run {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            font-weight: 700;
            border: none;
            height: 36px;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }

        .btn-run:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            color: white;
            font-weight: 700;
            border: none;
            height: 36px;
            font-size: 0.9rem;
        }

        .btn-stop:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4);
        }

        .chart-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            height: calc(100vh - 320px);
            min-height: 250px;
        }

        .chart-box {
            background: var(--bg-panel);
            padding: 0.4rem 0.6rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .chart-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.2rem;
            align-items: center;
            font-size: 0.7rem;
        }

        .radio-group {
            display: flex;
            background: var(--bg-secondary);
            border-radius: 4px;
            padding: 1px;
        }

        .radio-btn {
            padding: 2px 6px;
            font-size: 0.65rem;
            cursor: pointer;
            border-radius: 3px;
        }

        .radio-btn.active {
            background: var(--bg-primary);
            color: var(--accent-cyan);
            font-weight: bold;
        }

        /* Modal Styles - Compact */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: var(--bg-panel);
            margin: 3vh auto;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 95%;
            max-width: 1200px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 6px;
        }

        .modal-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .close {
            color: var(--text-secondary);
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close:hover {
            color: white;
        }

        /* Protocol Activity Tracker Styles - Compact */
        .activity-container {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 4px;
            min-height: 40px;
            max-height: 80px;
            overflow-y: auto;
        }

        .activity-status {
            font-size: 0.7rem;
            padding: 3px 6px;
            border-radius: 4px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-3px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .activity-status.idle {
            color: var(--text-muted);
            background: transparent;
        }

        .activity-status.running {
            background: rgba(0, 212, 255, 0.1);
            color: var(--accent-cyan);
            border-left: 2px solid var(--accent-cyan);
        }

        .activity-status.pixel {
            background: rgba(0, 212, 255, 0.15);
            color: var(--accent-cyan);
            border-left: 2px solid var(--accent-cyan);
            font-weight: 600;
        }

        .activity-status.saving {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-green);
            border-left: 2px solid var(--accent-green);
        }

        .activity-status.complete {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
            border-left: 2px solid var(--accent-green);
        }

        .activity-status.error {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
            border-left: 2px solid #ef4444;
        }

        .activity-icon {
            font-size: 0.8rem;
        }

        .last-saved {
            margin-top: 4px;
            padding: 3px 6px;
            background: rgba(16, 185, 129, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(16, 185, 129, 0.2);
            font-size: 0.65rem;
        }

        .last-saved.hidden {
            display: none;
        }

        .saved-label {
            color: var(--text-muted);
            margin-right: 3px;
        }

        .saved-path {
            color: var(--accent-green);
            font-family: monospace;
            font-weight: 600;
        }

        /* Timeline Visualization Styles - Compact */
        .timeline-container {
            flex: 1;
            overflow: auto;
            background: var(--bg-primary);
            border-radius: 6px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 6px;
        }

        .timeline-mode-toggle {
            display: flex;
            background: var(--bg-secondary);
            border-radius: 4px;
            padding: 2px;
            gap: 2px;
        }

        .timeline-mode-btn {
            border: none;
            background: transparent;
            color: var(--text-secondary);
            padding: 4px 10px;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .timeline-mode-btn.active {
            background: var(--accent-cyan);
            color: #000;
        }

        .timeline-stats {
            display: flex;
            gap: 12px;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .timeline-stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .timeline-stat-value {
            color: var(--accent-cyan);
            font-weight: 700;
        }

        .timeline-chart-wrapper {
            flex: 1;
            min-height: 250px;
            position: relative;
        }

        .timeline-legend {
            display: flex;
            gap: 12px;
            padding: 6px;
            background: var(--bg-secondary);
            border-radius: 4px;
            flex-wrap: wrap;
        }

        .timeline-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .timeline-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .timeline-details {
            max-height: 120px;
            overflow-y: auto;
            background: var(--bg-secondary);
            border-radius: 4px;
            padding: 6px;
        }

        .timeline-details-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--accent-cyan);
            margin-bottom: 4px;
        }

        .timeline-stage {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 3px 6px;
            margin-bottom: 2px;
            background: var(--bg-primary);
            border-radius: 3px;
            font-size: 0.65rem;
        }

        .timeline-stage-time {
            color: var(--accent-yellow);
            font-weight: 600;
            min-width: 45px;
        }

        .timeline-stage-duration {
            color: var(--text-muted);
            min-width: 40px;
        }

        .timeline-stage-action {
            color: var(--text-primary);
            flex: 1;
        }

        .timeline-stage-s1 {
            padding: 1px 5px;
            border-radius: 2px;
            font-weight: 600;
            font-size: 0.6rem;
        }

        .timeline-stage-s1-active {
            background: rgba(0, 212, 255, 0.2);
            color: var(--accent-cyan);
        }

        .timeline-stage-s2 {
            padding: 1px 5px;
            border-radius: 2px;
            font-weight: 600;
            font-size: 0.6rem;
        }

        .timeline-stage-s2-off {
            background: rgba(100, 100, 100, 0.3);
            color: #888;
        }

        .timeline-stage-s2-on {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
    </style>
</head>

<body style="overflow: hidden;">
    <div class="container" style="padding: 0.3rem 0.5rem;">
        <div class="page-header" style="margin-bottom: 0.3rem; padding-bottom: 0.3rem;">
            <h1 class="page-title" style="font-size: 1.1rem;">üìà Protocol Runner</h1>
        </div>

        <div class="runner-container">
            <!-- Left: Sidebar -->
            <div class="sidebar">
                <div class="panel" style="padding: 0.5rem;">
                    <div class="panel-title" style="font-size: 0.8rem; margin-bottom: 0.3rem;">Protocol Selection</div>
                    <div class="protocol-source-toggle" style="margin-bottom: 0.3rem;">
                        <button class="source-btn active" onclick="setSource('user')" id="srcUser" style="padding: 4px; font-size: 0.7rem;">User</button>
                        <button class="source-btn" onclick="setSource('all')" id="srcAll" style="padding: 4px; font-size: 0.7rem;">All</button>
                    </div>

                    <button class="btn btn-outline btn-xs btn-full mb-1" style="padding: 2px 6px; font-size: 0.7rem;" onclick="loadProtocolsList()">üîÑ Refresh</button>

                    <div class="protocol-list-mini" id="protocolList">
                        <div class="text-center p-2 text-muted" style="font-size: 0.7rem;">Loading...</div>
                    </div>
                </div>

                <div class="panel-title flex-between" style="font-size: 0.75rem; margin: 0.3rem 0;">
                    <span>Current Protocol</span>
                    <button class="btn btn-outline btn-xs" style="padding: 2px 6px; font-size: 0.65rem;" id="btnVisualize" onclick="visualizeProtocol()" disabled>üîç Viz</button>
                </div>
                <pre class="code-block" style="font-size: 0.6rem; max-height: 80px; margin: 0;"
                    id="yamlPreview">Select a protocol</pre>

                <!-- Protocol Activity Tracker -->
                <div class="panel" style="margin-top: 0.3rem; padding: 0.4rem;">
                    <div class="panel-title" style="font-size: 0.75rem; margin-bottom: 0.2rem;">üì¢ Activity</div>
                    <div id="protocolActivity" class="activity-container" style="min-height: 50px; max-height: 80px; padding: 4px;">
                        <div class="activity-status idle" style="padding: 4px 8px; font-size: 0.7rem;">Waiting...</div>
                    </div>
                    <div id="lastSavedFile" class="last-saved hidden" style="margin-top: 4px; padding: 4px 8px; font-size: 0.65rem;">
                        <span class="saved-label">Saved:</span>
                        <span class="saved-path" id="savedFilePath">--</span>
                    </div>
                </div>
            </div>

            <!-- Right: Main Area -->
            <div class="main-content">
                <!-- 1. Metrics -->
                <div class="metrics-bar">
                    <div class="metric-card" style="border-left-color: var(--accent-cyan);">
                        <div class="metric-label">System State</div>
                        <div class="metric-value" id="valState">IDLE</div>
                    </div>
                    <div class="metric-card" style="border-left-color: var(--accent-yellow);">
                        <div class="metric-label">Duration</div>
                        <div class="metric-value" id="valDuration">0.0s</div>
                    </div>
                    <div class="metric-card" style="border-left-color: var(--accent-cyan);">
                        <div class="metric-label">Data Points</div>
                        <div class="metric-value" id="valPoints">0</div>
                    </div>
                    <div class="metric-card"
                        style="border-left-color: var(--accent-green); position: relative; overflow: hidden;">
                        <div class="metric-label">Progress</div>
                        <div class="metric-value" id="valProgress">0%</div>
                        <div id="progressBar"
                            style="position: absolute; bottom: 0; left: 0; height: 4px; background: var(--accent-green); width: 0%; transition: width 0.3s;">
                        </div>
                    </div>
                </div>

                <!-- 2. Parameter Overrides -->
                <div class="override-section collapsed" id="setupSection">
                    <div class="section-header" onclick="toggleSetup()">
                        <span id="setupToggleIcon">‚ñ∂</span> üõ†Ô∏è Setup & Parameters (click to expand)
                    </div>

                    <div id="setupContent">
                        <!-- üõ°Ô∏è Global Overrides -->
                        <div class="form-group mb-2">
                            <label class="checkbox-label">
                                <input type="checkbox" id="mockOverride">
                                <strong>üõ°Ô∏è Global Mock Mode</strong> (Force mock=true for all HW)
                            </label>
                        </div>

                        <hr class="divider mb-2">

                        <!-- üì¶ Filename & Folder Replacement -->
                        <div class="group-title">1. Filename & Folder Replacement</div>
                        <div class="form-row mb-2">
                            <div class="form-group mb-0">
                                <label>Mode</label>
                                <div class="radio-group" style="width: fit-content;">
                                    <div class="radio-btn active" id="modeFNR" onclick="setFnameMode('fnr')">Find &
                                        Replace
                                    </div>
                                    <div class="radio-btn" id="modeLiteral" onclick="setFnameMode('literal')">Literal
                                        (Global)</div>
                                </div>
                            </div>
                        </div>

                        <div id="fnrFields" class="form-row">
                            <div class="form-group">
                                <label>Find</label>
                                <input type="text" id="fnameFind" value="TEST">
                            </div>
                            <div class="form-group">
                                <label>Replace with</label>
                                <input type="text" id="fnameReplace" value="AA1">
                            </div>
                        </div>

                        <div id="literalFields" class="form-row hidden">
                            <div class="form-group">
                                <label>New Filename (Global)</label>
                                <input type="text" id="fnameGlobal" value="DATA">
                            </div>
                        </div>

                        <div class="form-row mt-2">
                            <div class="form-group">
                                <label>Data Folder (Global)</label>
                                <input type="text" id="dataFolder" value="./data">
                            </div>
                        </div>

                        <hr class="divider mt-2 mb-2">

                        <!-- üåÄ Pixels -->
                        <div class="group-title">2. Pixels (Global Override)</div>
                        <div class="form-group">
                            <label>Pixel Sequence (e.g. 1-6 or 1,2,8)</label>
                            <input type="text" id="pixelOverride" value="">
                            <div class="text-tiny text-muted mt-1 italic">Targets all Pixel and Loop/Pixel actions.
                            </div>
                        </div>

                        <hr class="divider mt-2 mb-2">

                        <!-- ‚öôÔ∏è Parameters -->
                        <div class="group-title">3. Global Parameter Overrides</div>
                        <div id="dynamicParams" class="mt-2">
                            <div class="text-muted text-small">Select a protocol to see parameters.</div>
                        </div>

                        <hr class="divider mt-2 mb-2">

                        <!-- üí° Light Source -->
                        <div class="group-title">4. Light Source Override</div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Mode</label>
                                <select id="lightMode" onchange="toggleLightMode()">
                                    <option value="none">Use Protocol Default</option>
                                    <option value="current">Force Current (A)</option>
                                    <option value="irradiance">Force Irradiance (W/cm¬≤)</option>
                                </select>
                            </div>
                        </div>

                        <div id="lightCurrentGroup" class="hidden">
                            <div class="form-group">
                                <label>LED Current (A)</label>
                                <input type="number" id="lightCurrent" value="0.001" step="0.0001">
                            </div>
                        </div>

                        <div id="lightIrradianceGroup" class="hidden">
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Calibration File</label>
                                    <select id="calFile" onchange="loadCalData()"></select>
                                </div>
                                <div class="form-group" id="targetIrrWrap">
                                    <label>Target (W/cm¬≤)</label>
                                    <input type="number" id="targetIrr" value="0.001" step="0.0001"
                                        oninput="calculateCurrent()">
                                </div>
                            </div>
                            <div id="calResult" class="text-success text-small font-bold"></div>
                        </div>

                        <hr class="divider mt-2 mb-2">

                        <!-- üîÑ Dynamic Loop Overrides -->
                        <div class="group-title">4. Dynamic Loop Overrides</div>
                        <div id="dynamicLoops" class="mt-2">
                            <div class="text-muted text-small">Select a protocol to see available loops.</div>
                        </div>
                    </div>
                </div>

                <!-- 3. Execution Controls -->
                <div class="btn-row gap-1 mb-2">
                    <button id="btnRun" class="btn btn-run" style="flex: 2;" onclick="runProtocol()">RUN
                        PROTOCOL</button>
                    <button id="btnStop" class="btn btn-stop" style="flex: 1;" onclick="abortProtocol()" disabled>STOP
                        SCAN</button>
                </div>

                <!-- 4. Real-time Charts -->
                <div class="chart-grid">
                    <!-- IV Plot -->
                    <div class="chart-box">
                        <div class="flex-between">
                            <div class="panel-title" style="font-size: 0.75rem;">üìä IV Curves</div>
                            <div class="chart-controls">
                                <div class="radio-group">
                                    <div class="radio-btn active" id="modeAccum" onclick="setPlotMode('accumulate')">Accum</div>
                                    <div class="radio-btn" id="modeLatest" onclick="setPlotMode('latest')">Latest</div>
                                </div>
                                <div class="radio-group">
                                    <div class="radio-btn active" id="scaleLinear" onclick="setScaleMode('linear')">Lin</div>
                                    <div class="radio-btn" id="scaleLog" onclick="setScaleMode('log')">Log</div>
                                </div>
                            </div>
                        </div>
                        <div style="flex: 1; min-height: 0;">
                            <canvas id="ivChart"></canvas>
                        </div>
                    </div>

                    <!-- Steady State Plot -->
                    <div class="chart-box" id="steadyBox">
                        <div class="panel-title" style="font-size: 0.75rem;">‚è±Ô∏è Steady State</div>
                        <div style="flex: 1; min-height: 0;">
                            <canvas id="steadyChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Visualization Modal -->
    <div id="visualizeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="flex-between" style="gap: 20px; flex: 1;">
                    <span class="modal-title" id="vizModalTitle">Protocol Timeline</span>
                </div>
                <span class="close" onclick="closeVisualizeModal()">&times;</span>
            </div>
            
            <!-- Timeline Header with Controls -->
            <div class="timeline-header">
                <div class="timeline-mode-toggle">
                    <button class="timeline-mode-btn" id="timelineModeShort" onclick="setTimelineMode('short')">Short View</button>
                    <button class="timeline-mode-btn active" id="timelineModeLong" onclick="setTimelineMode('long')">Detailed View</button>
                </div>
                <div class="timeline-stats">
                    <div class="timeline-stat-item">
                        <span>Total Duration:</span>
                        <span class="timeline-stat-value" id="timelineTotalDuration">--</span>
                    </div>
                    <div class="timeline-stat-item">
                        <span>Switches:</span>
                        <span class="timeline-stat-value" id="timelineSwitchCount">--</span>
                    </div>
                    <div class="timeline-stat-item">
                        <span>Measurements:</span>
                        <span class="timeline-stat-value" id="timelineMeasCount">--</span>
                    </div>
                </div>
            </div>

            <!-- Legend -->
            <div class="timeline-legend">
                <div class="timeline-legend-item">
                    <div class="timeline-legend-color" style="background: rgba(0, 212, 255, 0.6);"></div>
                    <span>S1 (Pixel) Active</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="timeline-legend-color" style="background: rgba(255, 193, 7, 0.6);"></div>
                    <span>S2 (LED) ON</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="timeline-legend-color" style="background: rgba(100, 100, 100, 0.3);"></div>
                    <span>S2 (LED) OFF</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="timeline-legend-color" style="background: rgba(16, 185, 129, 0.6);"></div>
                    <span>Measurement</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="timeline-legend-color" style="background: rgba(239, 68, 68, 0.6);"></div>
                    <span>Wait/Delay</span>
                </div>
            </div>

            <!-- Timeline Chart -->
            <div class="timeline-chart-wrapper">
                <canvas id="timelineChart"></canvas>
            </div>

            <!-- Stage Details List -->
            <div class="timeline-details" id="timelineDetails">
                <div class="timeline-details-title">Protocol Stages</div>
                <div id="timelineStagesList"></div>
            </div>
        </div>
    </div>

    <script>
        // --- State ---
        let allProtocols = [];
        let sourceMode = 'user'; // 'user' | 'all'
        let selectedProtocol = null;
        let selectedYaml = null;
        let fnameMode = 'fnr'; // 'fnr' | 'literal'
        let plotMode = 'accumulate';
        let scaleMode = 'linear';
        let calData = null;

        let ivChart = null;
        let steadyChart = null;
        let timelineChart = null;
        let isRunning = false;
        let pollTimer = null;
        let historyCursor = 0;
        let traces = [];
        let steadyTraces = [];
        let startTime = 0;

        // Activity tracking state
        let currentPixel = null;
        let currentLedState = 'OFF';
        let lastSavedFile = null;
        let activityLog = [];

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initCharts();
            loadProtocolsList();
            loadCalibrationFiles();

            const user = UI2.getCurrentUser();
            if (user) document.getElementById('dataFolder').value = `./data/${user}`;
        });

        // --- Protocol Loading ---
        async function loadProtocolsList() {
            // Force backend to reload protocols from disk
            await UI2.reloadProtocols();
            const res = await UI2.getProtocolList();
            if (res && res.protocols) {
                allProtocols = res.protocols;
                renderProtocolList();
            }
        }

        function setSource(mode) {
            sourceMode = mode;
            document.getElementById('srcUser').classList.toggle('active', mode === 'user');
            document.getElementById('srcAll').classList.toggle('active', mode === 'all');
            renderProtocolList();
        }

        function renderProtocolList() {
            const user = UI2.getCurrentUser();
            let filtered = allProtocols;

            if (sourceMode === 'user' && user) {
                filtered = allProtocols.filter(p => p.id.startsWith(user + '/'));
            }

            const list = document.getElementById('protocolList');
            if (filtered.length === 0) {
                list.innerHTML = '<div class="text-center p-3 text-muted">No protocols found</div>';
                return;
            }

            list.innerHTML = filtered.map(p => `
                <div class="proto-item ${selectedProtocol && selectedProtocol.id === p.id ? 'active' : ''}" onclick="selectProtocol('${p.id}')">
                    <span class="name">${p.name || 'Unnamed'}</span>
                    <span class="id">${p.id}</span>
                </div>
            `).join('');
        }

        async function selectProtocol(id) {
            selectedProtocol = allProtocols.find(p => p.id === id);
            renderProtocolList();

            const res = await UI2.getProtocolContent(id);
            if (res.success) {
                selectedYaml = res.content;
                document.getElementById('yamlPreview').textContent = JSON.stringify(selectedYaml, null, 2);

                // Detect Loops & Params
                const loops = findLoops(selectedYaml.steps);
                renderDynamicLoops(loops);
                renderDynamicParams(selectedYaml.parameters || {});

                // Pre-fill pixel override if found
                if (selectedYaml.parameters && selectedYaml.parameters.pixel_id) {
                    document.getElementById('pixelOverride').value = selectedYaml.parameters.pixel_id;
                } else {
                    document.getElementById('pixelOverride').value = "";
                }

                document.getElementById('btnVisualize').disabled = false;

                // Pre-fill calibration if found in meta
                if (selectedYaml.parameters && selectedYaml.parameters.cal_file) {
                    const select = document.getElementById('calFile');
                    if (select) {
                        select.value = selectedYaml.parameters.cal_file;
                        loadCalData();
                    }
                }
            }
        }

        function renderDynamicLoops(loops) {
            const container = document.getElementById('dynamicLoops');
            if (loops.length === 0) {
                container.innerHTML = '<div class="text-muted text-small">No editable loops found in this protocol.</div>';
                return;
            }

            container.innerHTML = loops.map((l, i) => {
                const purpose = getLoopPurpose(l);
                const val = (l.params.sequence || []).join(', ') ||
                    (l.params.range ? `${l.params.range.start}-${l.params.range.stop} (Range)` : '');

                return `
                <div class="form-group mb-2" data-loop-idx="${i}">
                    <label class="flex-between">
                        <span>Loop: <span class="text-cyan font-bold">${l.params.variable}</span></span>
                        <span class="text-muted text-tiny italic">${purpose}</span>
                    </label>
                    <input type="text" class="loop-override-val" 
                           data-loop-idx="${i}"
                           data-variable="${l.params.variable}"
                           value="${val}">
                </div>
            `}).join('');
        }

        function renderDynamicParams(params) {
            const container = document.getElementById('dynamicParams');
            const keys = Object.keys(params);
            if (keys.length === 0) {
                container.innerHTML = '<div class="text-muted text-small">No global parameters found.</div>';
                return;
            }

            container.innerHTML = keys.map(key => `
                <div class="form-group mb-2">
                    <label>${key}</label>
                    <input type="text" class="param-override-val" 
                           data-key="${key}"
                           value="${params[key]}">
                </div>
            `).join('');
        }

        function getLoopPurpose(loop) {
            const steps = loop.steps || [];
            const actions = steps.map(s => s.action).join(' ');
            const vars = JSON.stringify(steps).toLowerCase();

            if (actions.includes('relays/pixel')) {
                if (vars.includes('dark')) return "Pixel Mapping (Dark)";
                if (vars.includes('light')) return "Pixel Mapping (Light)";
                return "Pixel Mapping";
            }
            if (actions.includes('smu/set') && vars.includes('intensity')) return "Intensity Sweep";
            if (actions.includes('sweep') && actions.includes('save')) {
                if (vars.includes('dark')) return "Measurement Sweep (Dark)";
                if (vars.includes('light')) return "Measurement Sweep (Light)";
                return "Measurement Sweep";
            }
            if (actions.includes('wait') && steps.length < 3) return "Wait/Delay Loop";

            return "General Loop";
        }

        // --- UI Initialization ---
        function toggleSetup() {
            const section = document.getElementById('setupSection');
            const icon = document.getElementById('setupToggleIcon');
            section.classList.toggle('collapsed');
            icon.textContent = section.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
        }

        // --- Overrides Logic ---
        function setFnameMode(mode) {
            fnameMode = mode;
            document.getElementById('modeFNR').classList.toggle('active', mode === 'fnr');
            document.getElementById('modeLiteral').classList.toggle('active', mode === 'literal');
            document.getElementById('fnrFields').classList.toggle('hidden', mode !== 'fnr');
            document.getElementById('literalFields').classList.toggle('hidden', mode !== 'literal');
        }

        function toggleLightMode() {
            const mode = document.getElementById('lightMode').value;
            document.getElementById('lightCurrentGroup').classList.toggle('hidden', mode !== 'current');
            document.getElementById('lightIrradianceGroup').classList.toggle('hidden', mode !== 'irradiance');

            // If we have an intensity loop, maybe we want to hide the single target input
            const hasIntensityLoop = !!document.querySelector('.loop-override-val[data-variable="intensity_val"]');
            document.getElementById('targetIrrWrap').classList.toggle('hidden', mode === 'irradiance' && hasIntensityLoop);
        }

        async function loadCalibrationFiles() {
            const files = await UI2.getCalibrationFiles();
            const select = document.getElementById('calFile');
            select.innerHTML = files.map(f => `<option value="${f}">${f}</option>`).join('');
            if (files.length > 0) loadCalData();
        }

        async function loadCalData() {
            const file = document.getElementById('calFile').value;
            const res = await UI2.getCalibrationData(file);
            if (res.success) {
                calData = res;
                calculateCurrent();
            }
        }

        function calculateCurrent() {
            if (!calData) return;
            const target = parseFloat(document.getElementById('targetIrr').value);

            function interpolate(x, xArr, yArr) {
                if (x <= xArr[0]) return yArr[0];
                if (x >= xArr[xArr.length - 1]) return yArr[yArr.length - 1];
                for (let i = 0; i < xArr.length - 1; i++) {
                    if (x >= xArr[i] && x <= xArr[i + 1]) {
                        const t = (x - xArr[i]) / (xArr[i + 1] - xArr[i]);
                        return yArr[i] + t * (yArr[i + 1] - yArr[i]);
                    }
                }
                return yArr[0];
            }

            const current = interpolate(target, calData.irradiances, calData.currents);
            document.getElementById('lightCurrent').value = current.toFixed(8);
            document.getElementById('calResult').textContent = `‚Üí ${current.toFixed(8)} A (${calData.format})`;
        }

        // --- Helpers for Overrides ---
        function findSteps(steps, action) {
            let found = [];
            for (let s of steps) {
                if (s.action === action) found.push(s);
                if (s.steps) found = found.concat(findSteps(s.steps, action));
            }
            return found;
        }

        function findLoops(steps) {
            let found = [];
            for (let s of steps) {
                if (s.action === 'control/loop') found.push(s);
                if (s.steps) found = found.concat(findLoops(s.steps));
            }
            return found;
        }

        // --- Run Logic ---
        // Activity tracking helper functions
        function updateActivity(statusType, message, details = '') {
            const container = document.getElementById('protocolActivity');
            const iconMap = {
                'idle': '‚è≥',
                'running': '‚ñ∂Ô∏è',
                'pixel': 'üìç',
                'saving': 'üíæ',
                'complete': '‚úÖ',
                'error': '‚ùå'
            };
            
            const icon = iconMap[statusType] || '‚óã';
            const html = `
                <div class="activity-status ${statusType}">
                    <span class="activity-icon">${icon}</span>
                    <div>
                        <div>${message}</div>
                        ${details ? `<div style="font-size: 0.7rem; opacity: 0.8; margin-top: 2px;">${details}</div>` : ''}
                    </div>
                </div>
            `;
            
            // Add new status at the top
            container.insertAdjacentHTML('afterbegin', html);
            
            // Keep only last 5 entries
            while (container.children.length > 5) {
                container.removeChild(container.lastChild);
            }
            
            // Log to console
            console.log(`[Activity] ${statusType}: ${message} ${details}`);
        }

        function updateSavedFile(filepath) {
            const container = document.getElementById('lastSavedFile');
            const pathEl = document.getElementById('savedFilePath');
            pathEl.textContent = filepath;
            container.classList.remove('hidden');
        }

        function resetActivity() {
            currentPixel = null;
            currentLedState = 'OFF';
            lastSavedFile = null;
            activityLog = [];
            document.getElementById('protocolActivity').innerHTML = '<div class="activity-status idle">Waiting to start...</div>';
            document.getElementById('lastSavedFile').classList.add('hidden');
            document.getElementById('savedFilePath').textContent = '--';
        }

        async function runProtocol() {
            if (!selectedYaml) return alert("Select a protocol first!");
            
            // Reset activity tracking
            resetActivity();
            updateActivity('running', 'Starting protocol...', selectedProtocol.id);

            const yaml = Utils.deepClone(selectedYaml);
            const user = UI2.getCurrentUser();
            const forceMock = document.getElementById('mockOverride').checked;

            // Apply Overrides
            // 0. Global Mock Override
            if (forceMock) {
                const hwActions = ['smu/connect', 'relays/connect', 'multipixel/connect'];
                const applyMock = (steps) => {
                    steps.forEach(s => {
                        if (hwActions.includes(s.action)) {
                            s.params.mock = true;
                        }
                        if (s.steps) applyMock(s.steps);
                    });
                };
                applyMock(yaml.steps);
            }

            // 1. Filenames & Folders
            const saveSteps = findSteps(yaml.steps, 'data/save');
            const dataFolder = document.getElementById('dataFolder').value;
            saveSteps.forEach(s => {
                s.params.folder = dataFolder;
                if (fnameMode === 'literal') {
                    s.params.filename = document.getElementById('fnameGlobal').value;
                } else {
                    const find = document.getElementById('fnameFind').value;
                    const repl = document.getElementById('fnameReplace').value;
                    s.params.filename = s.params.filename.replace(find, repl);
                }
            });

            // 2. Global Pixel Overrides
            const pixelVal = document.getElementById('pixelOverride').value;
            if (pixelVal) {
                const pixelSteps = findSteps(yaml.steps, 'relays/pixel');
                const isSequence = pixelVal.includes(',') || pixelVal.includes('-');

                if (!isSequence) {
                    const intPixel = parseInt(pixelVal);

                    // Attempt to find the "original" pixel from the selected YAML to automate filename replacement
                    const firstPixelStep = findSteps(selectedYaml.steps, 'relays/pixel')[0];
                    const originalPixel = firstPixelStep ? firstPixelStep.params.pixel_id : null;

                    pixelSteps.forEach(s => {
                        // Protect loop variables: only override literal values
                        if (typeof s.params.pixel_id !== 'string' || !s.params.pixel_id.startsWith('$')) {
                            s.params.pixel_id = intPixel;
                        }
                    });

                    // Automatically update filenames if original pixel is found
                    if (originalPixel !== null && originalPixel !== intPixel) {
                        const saveSteps = findSteps(yaml.steps, 'data/save');
                        const findP1 = `_P${originalPixel}_`;
                        const replP1 = `_P${intPixel}_`;
                        const findP2 = `_P${originalPixel}.`;
                        const replP2 = `_P${intPixel}.`;
                        saveSteps.forEach(s => {
                            if (s.params.filename.includes(findP1)) s.params.filename = s.params.filename.split(findP1).join(replP1);
                            if (s.params.filename.includes(findP2)) s.params.filename = s.params.filename.split(findP2).join(replP2);
                        });
                    }
                } else {
                    // It's a sequence - target loops instead of flat steps
                    const pixelLoops = findLoops(yaml.steps).filter(l => l.params.variable === 'pixel' || l.params.variable === 'pixel_id');
                    const seq = Utils.parsePixelString(pixelVal);
                    pixelLoops.forEach(l => l.params.sequence = seq);
                }
            }

            // 3. Global Parameter Overrides
            if (!yaml.parameters) yaml.parameters = {};
            const paramInputs = document.querySelectorAll('.param-override-val');
            paramInputs.forEach(input => {
                const key = input.getAttribute('data-key');
                const val = isNaN(input.value) ? input.value : parseFloat(input.value);
                yaml.parameters[key] = val;

                // We DON'T pre-apply these to steps to avoid destroying $var logic. 
                // The engine will resolve them from the parameters block.
            });

            // 4. Dynamic Loop Overrides (Targeted by Index)
            const overrideInputs = document.querySelectorAll('.loop-override-val');
            const allLoopsInYaml = findLoops(yaml.steps);

            overrideInputs.forEach(input => {
                const loopIdx = parseInt(input.getAttribute('data-loop-idx'));
                const varName = input.getAttribute('data-variable');
                const rawVal = input.value;
                const targetLoop = allLoopsInYaml[loopIdx];

                if (!targetLoop) return;

                let seq = rawVal.split(',').map(v => v.trim()).filter(v => v).map(v => {
                    return isNaN(v) ? v : parseFloat(v);
                });

                // Clear range if we are setting a sequence
                if (seq.length > 0) {
                    delete targetLoop.params.range;
                    targetLoop.params.sequence = seq;
                }

                // Special case: if this is an intensity loop and we are in irradiance mode
                if (varName === 'intensity_val' && document.getElementById('lightMode').value === 'irradiance' && calData) {
                    // Convert the sequence to current via calibration
                    function interpolate(x, xArr, yArr) {
                        if (x <= xArr[0]) return yArr[0];
                        if (x >= xArr[xArr.length - 1]) return yArr[yArr.length - 1];
                        for (let i = 0; i < xArr.length - 1; i++) {
                            if (x >= xArr[i] && x <= xArr[i + 1]) {
                                const t = (x - xArr[i]) / (xArr[i + 1] - xArr[i]);
                                return yArr[i] + t * (yArr[i + 1] - yArr[i]);
                            }
                        }
                        return yArr[0];
                    }
                    targetLoop.params.sequence = seq.map(irrad => {
                        const curr = interpolate(irrad, calData.irradiances, calData.currents);
                        return parseFloat(curr.toFixed(8));
                    });
                }
            });

            // 4. Light Source Static Override (smu/set steps NOT inside loops)
            const lightMode = document.getElementById('lightMode').value;
            if (lightMode !== 'none') {
                const setSteps = findSteps(yaml.steps, 'smu/set');
                const ledVal = parseFloat(document.getElementById('lightCurrent').value);
                setSteps.forEach(s => {
                    // Only override if NOT already using a variable (loop-based)
                    if (typeof s.params.value !== 'string' || !s.params.value.startsWith('$')) {
                        s.params.value = ledVal;
                    }
                });
            }

            // Start API
            console.log('[API] POST /protocol/run-inline', yaml);
            const res = await UI2.runInlineProtocol(yaml);
            console.log('[API Response] run-inline:', res);
            
            if (res.success) {
                isRunning = true;
                startTime = Date.now();
                historyCursor = 0;
                traces = [];
                steadyTraces = [];
                ivChart.data.datasets = [];
                steadyChart.data.datasets = [];

                document.getElementById('btnRun').disabled = true;
                document.getElementById('btnStop').disabled = false;

                updateActivity('running', 'Protocol Started', selectedProtocol.id);
                Utils.showToast("Protocol Started!", 'success');
                startPolling();
            } else {
                alert("Failed to start: " + res.message);
            }
        }

        async function abortProtocol() {
            console.log('[API] POST /protocol/abort');
            const res = await UI2.abortProtocol();
            console.log('[API Response] abort:', res);
            isRunning = false;
            document.getElementById('btnStop').disabled = true;
            document.getElementById('btnRun').disabled = false;
            Utils.showToast("Abort Requested", 'warning');
        }

        function startPolling() {
            if (pollTimer) clearInterval(pollTimer);
            pollTimer = setInterval(poll, 1000);
        }

        async function poll() {
            if (!isRunning) return;

            // 1. Status
            console.log('[API] GET /protocol/status');
            const status = await UI2.getProtocolStatus();
            console.log('[API Response] status:', status);
            
            document.getElementById('valState').textContent = status.state;
            document.getElementById('valDuration').textContent = status.run_duration_seconds.toFixed(1) + 's';

            // Update Progress
            if (status.total_steps > 0) {
                const percent = Math.round((status.steps_completed / status.total_steps) * 100);
                document.getElementById('valProgress').textContent = percent + '%';
                document.getElementById('progressBar').style.width = percent + '%';
                
                // Show running status with step info
                if (status.steps_completed > 0 && status.steps_completed % 5 === 0) {
                    updateActivity('running', `Running... Step ${status.steps_completed}/${status.total_steps}`, `${percent}% complete`);
                }
            } else {
                document.getElementById('valProgress').textContent = '0%';
                document.getElementById('progressBar').style.width = '0%';
            }

            // Track current step info if available
            if (status.current_step) {
                console.log('[Activity] Current step:', status.current_step);
            }
            
            // Track current action from status
            if (status.current_action) {
                console.log('[Activity] Current action:', status.current_action);
            }

            if (status.state === 'COMPLETE' || status.state === 'ERROR' || status.state === 'IDLE') {
                isRunning = false;
                document.getElementById('btnRun').disabled = false;
                document.getElementById('btnStop').disabled = true;
                clearInterval(pollTimer);
                
                if (status.state === 'ERROR') {
                    updateActivity('error', 'Protocol Error', status.message || 'Unknown error');
                    alert("Protocol Error");
                } else {
                    updateActivity('complete', 'Protocol Complete', `${traces.length} measurements saved`);
                    Utils.showToast("Protocol Finished", 'success');
                }
            }

            // 2. History
            console.log('[API] GET /protocol/history');
            const history = await UI2.getProtocolHistory();
            console.log('[API Response] history events:', history?.length || 0);
            
            if (history && history.length > historyCursor) {
                const newEvents = history.slice(historyCursor);
                historyCursor = history.length;

                newEvents.forEach(e => {
                    console.log('[History Event]', e);
                    const varName = (e.variable || "").toLowerCase();
                    const isIV = varName.includes('iv');
                    const isSteady = varName.includes('steady');
                    
                    // Get context info
                    const ctx = e.context || {};
                    const pixel = ctx.pixel || ctx.pixel_id;
                    const action = e.action || '';

                    // Track pixel switching from context
                    if (pixel && currentPixel !== pixel) {
                        currentPixel = pixel;
                        const cond = currentLedState === 'ON' ? 'Light' : 'Dark';
                        updateActivity('pixel', `Testing Pixel ${pixel}`, `Condition: ${cond}`);
                    }
                    
                    // Track LED state from context
                    if (ctx.led_state !== undefined) {
                        const newState = ctx.led_state === true || ctx.led_state === 1 || ctx.led_state === 'ON' ? 'ON' : 'OFF';
                        if (currentLedState !== newState) {
                            currentLedState = newState;
                            console.log(`[Activity] LED state changed to: ${newState}`);
                        }
                    }

                    // Track measurement completion
                    if ((isIV || isSteady) && e.value && e.value.results) {
                        const results = e.value.results;
                        const targetList = isSteady ? steadyTraces : traces;

                        if (typeof results === 'object' && !Array.isArray(results)) {
                            // Multichannel
                            Object.keys(results).forEach(ch => {
                                targetList.push({ pixel, channel: ch, data: results[ch], name: e.variable });
                            });
                        } else {
                            targetList.push({ pixel, channel: e.value.channel || 1, data: results, name: e.variable });
                        }
                        
                        // Log measurement
                        console.log(`[Activity] Measurement complete: ${e.variable} for pixel ${pixel}`);
                    }
                    
                    // Track file saves from action or context
                    if (action === 'data/save' || e.variable?.includes('save') || (e.value && e.value.saved)) {
                        const filename = e.params?.filename || e.value?.filename || ctx.filename || 'unknown';
                        const folder = e.params?.folder || ctx.folder || './data';
                        const filepath = `${folder}/${filename}`;
                        lastSavedFile = filepath;
                        updateSavedFile(filepath);
                        updateActivity('saving', 'Data Saved', filepath);
                        console.log(`[Activity] File saved: ${filepath}`);
                    }
                    
                    // Track relay/pixel actions directly
                    if (action === 'relays/pixel' && e.params?.pixel_id) {
                        const pixelId = e.params.pixel_id;
                        if (currentPixel !== pixelId) {
                            currentPixel = pixelId;
                            const cond = currentLedState === 'ON' ? 'Light' : 'Dark';
                            updateActivity('pixel', `Testing Pixel ${pixelId}`, `Condition: ${cond}`);
                        }
                    }
                    
                    // Track LED actions
                    if (action === 'relays/led') {
                        const newState = e.params?.channel_id === 0 ? 'OFF' : 'ON';
                        if (currentLedState !== newState) {
                            currentLedState = newState;
                            console.log(`[Activity] LED state changed to: ${newState}`);
                        }
                    }
                });

                document.getElementById('valPoints').textContent = traces.reduce((acc, t) => acc + t.data.length, 0);
                updateCharts();
            }
        }

        // --- Plotting ---
        function initCharts() {
            const ivCtx = document.getElementById('ivChart').getContext('2d');
            ivChart = new Chart(ivCtx, {
                type: 'scatter',
                data: { datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: { title: { display: true, text: 'V (V)', color: '#888', font: {size: 9} }, grid: { color: '#333' }, ticks: { font: {size: 8} } },
                        y: { title: { display: true, text: 'I (A)', color: '#888', font: {size: 9} }, grid: { color: '#333' }, ticks: { font: {size: 8} } }
                    },
                    plugins: { legend: { position: 'right', labels: { boxWidth: 8, font: { size: 8 }, padding: 4 } } }
                }
            });

            const stdCtx = document.getElementById('steadyChart').getContext('2d');
            steadyChart = new Chart(stdCtx, {
                type: 'line',
                data: { datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: { type: 'linear', title: { display: true, text: 'Points', color: '#888', font: {size: 9} }, grid: { color: '#333' }, ticks: { font: {size: 8} } },
                        y: { title: { display: true, text: 'I (A)', color: '#888', font: {size: 9} }, grid: { color: '#333' }, ticks: { font: {size: 8} } }
                    },
                    plugins: { legend: { position: 'right', labels: { boxWidth: 8, font: { size: 8 }, padding: 4 } } }
                }
            });
        }

        function setPlotMode(mode) {
            plotMode = mode;
            document.getElementById('modeAccum').classList.toggle('active', mode === 'accumulate');
            document.getElementById('modeLatest').classList.toggle('active', mode === 'latest');
            updateCharts();
        }

        function setScaleMode(mode) {
            scaleMode = mode;
            document.getElementById('scaleLinear').classList.toggle('active', mode === 'linear');
            document.getElementById('scaleLog').classList.toggle('active', mode === 'log');

            ivChart.options.scales.y.type = mode === 'log' ? 'logarithmic' : 'linear';
            ivChart.options.scales.y.title.text = mode === 'log' ? '|I| (A)' : 'I (A)';
            steadyChart.options.scales.y.type = mode === 'log' ? 'logarithmic' : 'linear';
            updateCharts();
        }

        function updateCharts() {
            const colors = ['#00d4ff', '#00ff66', '#ff9900', '#ff4444', '#aa66ff', '#4488ff', '#ffffff'];

            // 1. IV Chart
            let ivToDisplay = plotMode === 'accumulate' ? traces : (traces.length > 0 ? [traces[traces.length - 1]] : []);
            ivChart.data.datasets = ivToDisplay.map((t, i) => {
                const label = t.pixel ? `Pix ${t.pixel} (${t.name})` : `Trace ${i}`;
                const points = t.data.map(p => {
                    const y = scaleMode === 'log' ? Math.max(1e-12, Math.abs(p.current)) : p.current;
                    return { x: p.voltage, y: y };
                });
                return {
                    label: label,
                    data: points,
                    borderColor: colors[i % colors.length],
                    showLine: true,
                    borderWidth: 2,
                    pointRadius: 1
                };
            });
            ivChart.update('none');

            // 2. Steady Chart
            let stdToDisplay = plotMode === 'accumulate' ? steadyTraces : (steadyTraces.length > 0 ? [steadyTraces[steadyTraces.length - 1]] : []);
            steadyChart.data.datasets = stdToDisplay.map((t, i) => {
                const label = t.pixel ? `Pix ${t.pixel} (${t.name})` : `Steady ${i}`;
                const points = t.data.map((p, idx) => {
                    const y = scaleMode === 'log' ? Math.max(1e-12, Math.abs(p.current)) : p.current;
                    return { x: idx, y: y };
                });
                return {
                    label: label,
                    data: points,
                    borderColor: colors[i % colors.length],
                    borderWidth: 2,
                    pointRadius: 0
                };
            });
            steadyChart.update('none');
        }

        // --- Visualization ---
        let timelineMode = 'long'; // 'short' | 'long'

        function closeVisualizeModal() {
            document.getElementById('visualizeModal').style.display = 'none';
        }

        function setTimelineMode(mode) {
            timelineMode = mode;
            document.getElementById('timelineModeShort').classList.toggle('active', mode === 'short');
            document.getElementById('timelineModeLong').classList.toggle('active', mode === 'long');
            visualizeProtocol();
        }

        async function visualizeProtocol() {
            if (!selectedYaml) return;

            const modal = document.getElementById('visualizeModal');
            const title = document.getElementById('vizModalTitle');

            title.textContent = `Timeline: ${selectedProtocol.id}`;
            modal.style.display = 'block';

            if (!selectedYaml.steps || selectedYaml.steps.length === 0) {
                document.getElementById('timelineStagesList').innerHTML = '<div class="text-muted">No steps to visualize.</div>';
                return;
            }

            // Parse protocol into timeline events
            const timeline = parseProtocolToTimeline(selectedYaml.steps, timelineMode);
            
            // Update stats
            document.getElementById('timelineTotalDuration').textContent = formatDuration(timeline.totalDuration);
            document.getElementById('timelineSwitchCount').textContent = timeline.switchCount;
            document.getElementById('timelineMeasCount').textContent = timeline.measCount;

            // Render stage list
            renderTimelineStages(timeline.stages);

            // Render chart
            renderTimelineChart(timeline);
        }

        function parseProtocolToTimeline(steps, mode) {
            const stages = [];
            let currentTime = 0;
            let currentS1 = 'OFF';  // Current pixel
            let currentS2 = 'OFF';  // LED state (OFF/ON)
            let switchCount = 0;
            let measCount = 0;

            function addStage(stage) {
                stages.push({
                    ...stage,
                    startTime: currentTime,
                    endTime: currentTime + stage.duration,
                    s1: currentS1,
                    s2: currentS2
                });
                currentTime += stage.duration;
            }

            // Track NPLC per SMU channel (from smu/configure steps)
            const channelNPLC = { 1: 1, 2: 1 };  // Default NPLC = 1

            function processStep(step, loopContext = {}) {
                const action = step.action || '';
                const params = step.params || {};

                // Handle different action types
                if (action === 'control/loop') {
                    const loopVar = params.variable;
                    const sequence = params.sequence || (params.range ? generateRange(params.range) : []);
                    const loopSteps = step.steps || [];
                    const loopCount = params.count || sequence.length || 1;

                    for (let i = 0; i < loopCount; i++) {
                        const ctx = { ...loopContext, [loopVar]: sequence[i] || i };
                        for (const subStep of loopSteps) {
                            processStep(subStep, ctx);
                        }
                    }
                    return;
                }

                // Check if this step should be included based on mode
                const isShortFiltered = mode === 'short' && (
                    action.includes('connect') ||
                    action.includes('configure') ||
                    action === 'smu/source-mode' ||
                    action === 'smu/set' ||
                    (action === 'smu/output' && !params.enabled) ||
                    action === 'relays/all-off'
                );

                // Track NPLC from configure steps
                if (action === 'smu/configure') {
                    const ch = params.channel || 1;
                    if (params.nplc !== undefined) {
                        channelNPLC[ch] = params.nplc;
                    }
                    if (mode === 'long') {
                        addStage({
                            type: 'setup',
                            label: `Configure Ch${ch} (NPLC=${channelNPLC[ch]})`,
                            duration: 0.05,
                            action: action,
                            shortVisible: false
                        });
                    }
                    return;  // Don't process further for configure
                }

                // Handle state changes
                if (action === 'relays/pixel') {
                    const pixelId = resolveValue(params.pixel_id, loopContext);
                    if (currentS1 !== pixelId) {
                        currentS1 = pixelId === 0 || pixelId === '0' ? 'OFF' : `P${pixelId}`;
                        switchCount++;
                    }
                    if (mode === 'short') {
                        addStage({
                            type: 'switch_s1',
                            label: `Switch to Pixel ${pixelId}`,
                            duration: 0.1,
                            action: action
                        });
                    }
                } else if (action === 'relays/led') {
                    const ledState = params.channel_id === 0 ? 'OFF' : 'ON';
                    if (currentS2 !== ledState) {
                        currentS2 = ledState;
                        switchCount++;
                    }
                    if (mode === 'short') {
                        addStage({
                            type: 'switch_s2',
                            label: `LED ${ledState}`,
                            duration: 0.1,
                            action: action
                        });
                    }
                } else if (action === 'relays/all-off') {
                    if (currentS1 !== 'OFF') {
                        currentS1 = 'OFF';
                        switchCount++;
                    }
                    if (currentS2 !== 'OFF') {
                        currentS2 = 'OFF';
                        switchCount++;
                    }
                } else if (action === 'wait') {
                    const duration = params.seconds || params.duration || 0;
                    if (!isShortFiltered || duration > 0.5) {
                        addStage({
                            type: 'wait',
                            label: `Wait ${duration}s`,
                            duration: duration,
                            action: action,
                            shortVisible: mode === 'long' || duration > 1
                        });
                    }
                } else if (action === 'smu/sweep') {
                    const points = params.points || 10;
                    const delay = params.delay || 0.05;
                    const channel = params.channel || 1;
                    const nplc = channelNPLC[channel] || 1;
                    
                    // Realistic timing calculation:
                    // duration = points * (delay + NPLC * 20ms + 0.5ms comms overhead)
                    const nplcTime = nplc * 0.020;  // 20ms per NPLC
                    const commsOverhead = 0.0005;   // 0.5ms per point
                    const pointTime = delay + nplcTime + commsOverhead;
                    const duration = points * pointTime;
                    
                    measCount++;
                    addStage({
                        type: 'measurement',
                        label: `Sweep ${params.start}V‚Üí${params.stop}V (${points}pts, NPLC=${nplc})`,
                        duration: duration,
                        action: action,
                        channel: channel,
                        shortVisible: true
                    });
                } else if (action === 'smu/output' && params.enabled) {
                    // Output ON - usually part of setup, brief
                    if (mode === 'long') {
                        addStage({
                            type: 'setup',
                            label: `Output ON (Ch${params.channel})`,
                            duration: 0.05,
                            action: action,
                            shortVisible: false
                        });
                    }
                } else {
                    // Other setup actions
                    if (mode === 'long' && !isShortFiltered) {
                        addStage({
                            type: 'setup',
                            label: action,
                            duration: 0.1,
                            action: action,
                            shortVisible: false
                        });
                    }
                }
            }

            // Process all steps
            for (const step of steps) {
                processStep(step);
            }

            return {
                stages: stages,
                totalDuration: currentTime,
                switchCount: switchCount,
                measCount: measCount
            };
        }

        function resolveValue(value, context) {
            if (typeof value === 'string' && value.startsWith('$')) {
                const varName = value.slice(1);
                return context[varName] !== undefined ? context[varName] : value;
            }
            return value;
        }

        function generateRange(range) {
            const result = [];
            const start = range.start || 0;
            const stop = range.stop || 0;
            const step = range.step || 1;
            for (let i = start; i <= stop; i += step) {
                result.push(i);
            }
            return result;
        }

        function formatDuration(seconds) {
            if (seconds < 60) {
                return `${seconds.toFixed(1)}s`;
            } else if (seconds < 3600) {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m}m ${s.toFixed(0)}s`;
            } else {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                return `${h}h ${m}m`;
            }
        }

        function renderTimelineStages(stages) {
            const container = document.getElementById('timelineStagesList');
            
            if (stages.length === 0) {
                container.innerHTML = '<div class="text-muted">No stages to display.</div>';
                return;
            }

            const html = stages.map((stage, idx) => {
                const s1Class = stage.s1 === 'OFF' ? '' : 'timeline-stage-s1-active';
                const s2Class = stage.s2 === 'ON' ? 'timeline-stage-s2-on' : 'timeline-stage-s2-off';
                
                return `
                    <div class="timeline-stage">
                        <span class="timeline-stage-time">${stage.startTime.toFixed(1)}s</span>
                        <span class="timeline-stage-duration">(${stage.duration.toFixed(2)}s)</span>
                        <span class="timeline-stage-action">${stage.label}</span>
                        <span class="timeline-stage-s1 ${s1Class}">S1: ${stage.s1}</span>
                        <span class="timeline-stage-s2 ${s2Class}">S2: ${stage.s2}</span>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function renderTimelineChart(timeline) {
            const ctx = document.getElementById('timelineChart').getContext('2d');

            // Collect all timeline items
            const items = [];
            
            // Track continuous states
            let lastS1 = 'OFF';
            let lastS2 = 'OFF';
            let s1Start = 0;
            let s2Start = 0;

            timeline.stages.forEach((stage, idx) => {
                // S1 State tracking (continuous)
                if (stage.s1 !== lastS1) {
                    if (lastS1 !== 'OFF') {
                        items.push({
                            lane: 3,
                            start: s1Start,
                            end: stage.startTime,
                            label: lastS1,
                            type: 's1',
                            color: 'rgba(0, 212, 255, 0.7)',
                            borderColor: 'rgba(0, 212, 255, 1)'
                        });
                    }
                    lastS1 = stage.s1;
                    s1Start = stage.startTime;
                }

                // S2 State tracking (continuous)
                if (stage.s2 !== lastS2) {
                    if (lastS2 === 'ON') {
                        items.push({
                            lane: 2,
                            start: s2Start,
                            end: stage.startTime,
                            label: 'LED ON',
                            type: 's2',
                            color: 'rgba(255, 193, 7, 0.7)',
                            borderColor: 'rgba(255, 193, 7, 1)'
                        });
                    }
                    lastS2 = stage.s2;
                    s2Start = stage.startTime;
                }

                // Measurements
                if (stage.type === 'measurement') {
                    items.push({
                        lane: 1,
                        start: stage.startTime,
                        end: stage.endTime,
                        label: stage.label,
                        type: 'measurement',
                        color: 'rgba(16, 185, 129, 0.7)',
                        borderColor: 'rgba(16, 185, 129, 1)'
                    });
                }

                // Waits (only if significant)
                if (stage.type === 'wait' && stage.duration > 0.05) {
                    items.push({
                        lane: 0,
                        start: stage.startTime,
                        end: stage.endTime,
                        label: stage.label,
                        type: 'wait',
                        color: 'rgba(239, 68, 68, 0.4)',
                        borderColor: 'rgba(239, 68, 68, 0.6)'
                    });
                }
            });

            // Close final state segments
            if (lastS1 !== 'OFF' && timeline.stages.length > 0) {
                const lastTime = timeline.stages[timeline.stages.length - 1].endTime;
                items.push({
                    lane: 3,
                    start: s1Start,
                    end: lastTime,
                    label: lastS1,
                    type: 's1',
                    color: 'rgba(0, 212, 255, 0.7)',
                    borderColor: 'rgba(0, 212, 255, 1)'
                });
            }
            if (lastS2 === 'ON' && timeline.stages.length > 0) {
                const lastTime = timeline.stages[timeline.stages.length - 1].endTime;
                items.push({
                    lane: 2,
                    start: s2Start,
                    end: lastTime,
                    label: 'LED ON',
                    type: 's2',
                    color: 'rgba(255, 193, 7, 0.7)',
                    borderColor: 'rgba(255, 193, 7, 1)'
                });
            }

            // Create scatter datasets - one point per item at center of time range
            // We'll use a custom plugin to draw the actual bars
            const scatterData = items.map(item => ({
                x: (item.start + item.end) / 2,
                y: item.lane,
                xMin: item.start,
                xMax: item.end,
                label: item.label,
                color: item.color,
                borderColor: item.borderColor,
                type: item.type,
                duration: item.end - item.start
            }));

            // Define custom plugin to draw timeline bars
            const timelinePlugin = {
                id: 'timelineBars',
                afterDatasetsDraw(chart) {
                    const ctx = chart.ctx;
                    const xScale = chart.scales.x;
                    const yScale = chart.scales.y;
                    const meta = chart.getDatasetMeta(0);

                    ctx.save();
                    
                    scatterData.forEach(item => {
                        const xStart = xScale.getPixelForValue(item.xMin);
                        const xEnd = xScale.getPixelForValue(item.xMax);
                        const y = yScale.getPixelForValue(item.y);
                        
                        // Bar height based on lane
                        const barHeight = item.type === 'wait' ? 20 : 30;
                        const yTop = y - barHeight / 2;
                        const width = xEnd - xStart;

                        // Draw bar
                        ctx.fillStyle = item.color;
                        ctx.strokeStyle = item.borderColor;
                        ctx.lineWidth = 1;
                        
                        // Rounded rectangle
                        const radius = 3;
                        ctx.beginPath();
                        ctx.roundRect(xStart, yTop, width, barHeight, radius);
                        ctx.fill();
                        ctx.stroke();

                        // Draw label if bar is wide enough
                        if (width > 40 && item.type !== 'wait') {
                            ctx.fillStyle = '#fff';
                            ctx.font = '10px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const label = item.label.length > 15 ? item.label.substring(0, 12) + '...' : item.label;
                            ctx.fillText(label, (xStart + xEnd) / 2, y);
                        }
                    });
                    
                    ctx.restore();
                }
            };

            if (timelineChart) {
                timelineChart.destroy();
            }

            timelineChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Timeline',
                        data: scatterData,
                        pointRadius: 0,  // Hide actual points
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    layout: {
                        padding: { left: 10, right: 10, top: 10, bottom: 10 }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            titleColor: '#00d4ff',
                            bodyColor: '#ccc',
                            borderColor: '#333',
                            borderWidth: 1,
                            callbacks: {
                                title: (items) => {
                                    if (!items || items.length === 0) return '';
                                    const raw = items[0].raw;
                                    return `${raw.xMin.toFixed(2)}s - ${raw.xMax.toFixed(2)}s (Œî${raw.duration.toFixed(2)}s)`;
                                },
                                label: (item) => {
                                    const raw = item.raw;
                                    const laneNames = ['Wait/Delay', 'Measurement', 'S2 (LED)', 'S1 (Pixel)'];
                                    return [
                                        `Type: ${laneNames[raw.y]}`,
                                        `Action: ${raw.label}`
                                    ];
                                }
                            }
                        },
                        timelineBars: {}  // Enable custom plugin
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time (seconds)',
                                color: '#888',
                                font: { size: 12 }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#888',
                                callback: (v) => v + 's'
                            },
                            min: 0,
                            max: timeline.totalDuration * 1.02
                        },
                        y: {
                            type: 'linear',
                            min: -0.5,
                            max: 3.5,
                            ticks: {
                                stepSize: 1,
                                color: '#aaa',
                                font: { size: 11, weight: 'bold' },
                                callback: (v) => {
                                    const labels = ['Wait/Delay', 'Measurement', 'S2 (LED)', 'S1 (Pixel)'];
                                    return labels[v] || '';
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            }
                        }
                    }
                },
                plugins: [timelinePlugin]
            });
        }
    </script>
</body>

</html>